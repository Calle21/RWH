(E elt) => ({E} seq)
  end = seq.end
  rec (i = seq.start)
  if
   i      > end  -> no
   seq[i] == elt -> yes
    else
    rec (i + 1)

(E elt) => (Sorted {E} seq)
  rec (upper = seq.end, lower = seq.start)
    if lower > upper
      no
      else
      mid = (lower + upper) / 2
      if
       elt < #a seq[mid] -> rec (mid - 1, lower)
       elt > #a          -> rec (upper, mid + 1)
        else
        yes

(E elt) => (Map KE map)
  if map == void
    no
    else
    elt is in map.left | elt is in map.right

(K key) => (Map KE map)
  if
   map == void      -> no
   key < #k map.key -> key => map.left
   key > #k         -> key => map.right
    else
    yes
